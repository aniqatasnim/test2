 Used the lazyLex replit code and extrastuff.ipynb and coded it in Java. 


* A: We are defining the rules for recognizing lexemes and having these lexemes/token being identified in a special way. In lexicalanalyzer.java, there is a class called lexicalanalyzer and inside there, there are static variables, character classes, token codes, operators, comparing vars, and regular symbols all being either an int or char type. These lexeme/tokens range from letters (a-zA-Z), digits(0-9),  regular symbols ($,&,@) arithetic symbols (-,+,=,*,), opening and closing brackets/parentheses([],{}), etc.

* B: We are defining production rules for the language. 
* C: show whether every rule set in your language conforms to the standard of an LL Grammar. Is this a grammar that can be solved top down or bottom up. Answering two Qs: if it has left hand recursion and if its pairwise disjoint. 
- tell if its PD and if it has LHR --> if it is, it doesnt comform to 
* D: Make sure it is not ambigious Grammar -->. making sure there is not two way to make a sentence. 
* E: should be OOP, and comments in the code 
* F: take in the list of token, 
* G: Creating test case files 
* H:  create and LR Parse Table 
